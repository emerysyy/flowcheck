# FlowEngine 单例模式说明

## 设计决策

FlowEngine 采用**单例模式**（Singleton Pattern），确保整个应用程序中只有一个 FlowEngine 实例。

### 为什么使用单例？

1. **共享 DNS 缓存**
   - 所有流量共享同一个 DNS 缓存
   - 提高缓存命中率
   - 减少 DNS 查询次数

2. **共享 IP-域名映射**
   - 所有流量共享 IP 到域名的映射
   - 更完整的网络拓扑信息

3. **统一的流量管理**
   - 集中管理所有网络流量
   - 便于统计和监控

4. **资源效率**
   - 避免重复创建相同的组件
   - 减少内存占用

---

## 使用方法

### 基本用法

```cpp
#include "flow/flow_engine.hpp"

// 获取单例实例
flow::FlowEngine& engine = flow::FlowEngine::getInstance();

// 使用 engine
flow::FlowContext ctx;
ctx.flow_type = flow::FlowType::TCP;
ctx.dst_port = 443;

flow::PacketView pkt{data, len};
engine.flowSend(ctx, pkt);
```

### 多线程使用

```cpp
void worker_thread() {
    // 所有线程共享同一个 FlowEngine 实例
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();

    while (true) {
        auto pkt = get_packet();
        flow::FlowContext ctx;

        // 线程安全：DNSEngine 内部有锁保护
        engine.flowSend(ctx, pkt);
    }
}

// 启动多个工作线程
std::thread t1(worker_thread);
std::thread t2(worker_thread);
std::thread t3(worker_thread);
```

### 访问 DNS 引擎

```cpp
// 获取 DNS 引擎以进行高级操作
flow::FlowEngine& engine = flow::FlowEngine::getInstance();
flow::DNSEngine& dns_engine = engine.getDNSEngine();

// 查询 IP 对应的域名
auto domains = dns_engine.getDomainsForIP("93.184.216.34");
for (const auto& domain : domains) {
    std::cout << "Domain: " << domain << std::endl;
}

// 清除缓存
dns_engine.clearCache();
```

---

## 实现细节

### 线程安全的单例

```cpp
flow::FlowEngine& FlowEngine::getInstance() {
    static FlowEngine instance;  // C++11 保证线程安全
    return instance;
}
```

**特点**：
- ✅ C++11 标准保证静态局部变量的初始化是线程安全的
- ✅ 延迟初始化：第一次调用时才创建
- ✅ 自动销毁：程序结束时自动销毁

### 禁止拷贝和赋值

```cpp
class FlowEngine {
public:
    // Delete copy constructor and assignment operator
    FlowEngine(const FlowEngine&) = delete;
    FlowEngine& operator=(const FlowEngine&) = delete;

    // ...
};
```

**防止**：
```cpp
flow::FlowEngine& engine1 = flow::FlowEngine::getInstance();
flow::FlowEngine engine2 = engine1;  // ❌ 编译错误
```

---

## 使用场景

### 场景 1：网络代理服务器

```cpp
class ProxyServer {
public:
    void handleConnection(Connection& conn) {
        // 所有连接共享同一个 FlowEngine
        flow::FlowEngine& engine = flow::FlowEngine::getInstance();

        flow::FlowContext ctx;
        ctx.dst_ip = conn.getDestIP();
        ctx.dst_port = conn.getDestPort();

        // 处理流量
        while (auto pkt = conn.readPacket()) {
            flow::PacketView pv{pkt.data(), pkt.size()};
            engine.flowSend(ctx, pv);
        }
    }
};

// 多个连接共享 DNS 缓存
ProxyServer server;
server.start();  // 处理多个并发连接
```

### 场景 2：DNS 代理

```cpp
class DNSProxy {
public:
    void handleQuery(const uint8_t* query, size_t len) {
        flow::FlowEngine& engine = flow::FlowEngine::getInstance();

        flow::FlowContext ctx;
        ctx.flow_type = flow::FlowType::UDP;
        ctx.dst_port = 53;

        flow::PacketView pkt{query, len};
        flow::PacketView response;

        if (engine.flowSend(ctx, pkt, response)) {
            // 缓存命中 - 所有客户端共享缓存
            sendResponse(response.data, response.len);
        } else {
            // 缓存未命中 - 转发到上游
            forwardToUpstream(query, len);
        }
    }
};
```

### 场景 3：流量监控

```cpp
class TrafficMonitor {
public:
    void monitorPacket(const uint8_t* data, size_t len) {
        flow::FlowEngine& engine = flow::FlowEngine::getInstance();
        flow::DNSEngine& dns_engine = engine.getDNSEngine();

        // 提取目标 IP
        std::string dst_ip = extractDestIP(data, len);

        // 查询 IP 对应的域名
        auto domains = dns_engine.getDomainsForIP(dst_ip);

        if (!domains.empty()) {
            std::cout << "Traffic to " << dst_ip
                      << " (" << domains[0] << ")" << std::endl;
        }
    }
};
```

---

## 优势

### 1. 共享缓存

**示例**：
```cpp
// 线程 1
flow::FlowEngine& engine = flow::FlowEngine::getInstance();
// 查询 example.com，缓存 DNS 响应

// 线程 2（稍后）
flow::FlowEngine& engine = flow::FlowEngine::getInstance();
// 查询 example.com，直接从缓存获取 ✓
```

### 2. 统一管理

```cpp
// 在任何地方都可以访问同一个实例
void function1() {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    // 使用 engine
}

void function2() {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    // 使用同一个 engine
}
```

### 3. 全局统计

```cpp
class FlowStatistics {
public:
    void printStats() {
        flow::FlowEngine& engine = flow::FlowEngine::getInstance();
        flow::DNSEngine& dns = engine.getDNSEngine();

        // 获取全局 DNS 缓存统计
        // （需要在 DNSEngine 中添加统计接口）
        std::cout << "Total DNS queries: " << /* ... */ << std::endl;
        std::cout << "Cache hit rate: " << /* ... */ << std::endl;
    }
};
```

---

## 注意事项

### 1. 线程安全

**DNSEngine 是线程安全的**：
```cpp
// 多个线程同时访问是安全的
void thread1() {
    flow::FlowEngine::getInstance().flowSend(ctx, pkt);
}

void thread2() {
    flow::FlowEngine::getInstance().flowSend(ctx, pkt);
}
```

**FlowContext 不是线程安全的**：
```cpp
// ❌ 错误：多个线程共享同一个 FlowContext
flow::FlowContext shared_ctx;

void thread1() {
    flow::FlowEngine::getInstance().flowSend(shared_ctx, pkt);  // 危险！
}

void thread2() {
    flow::FlowEngine::getInstance().flowSend(shared_ctx, pkt);  // 危险！
}

// ✓ 正确：每个线程使用独立的 FlowContext
void thread1() {
    flow::FlowContext ctx1;
    flow::FlowEngine::getInstance().flowSend(ctx1, pkt);  // 安全
}

void thread2() {
    flow::FlowContext ctx2;
    flow::FlowEngine::getInstance().flowSend(ctx2, pkt);  // 安全
}
```

### 2. 生命周期

```cpp
// FlowEngine 在程序结束时自动销毁
int main() {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    // 使用 engine

    return 0;
}  // engine 在这里自动销毁
```

### 3. 测试

```cpp
// 测试时需要注意缓存共享
TEST(FlowEngineTest, Test1) {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    // 测试代码
    // 注意：缓存会保留到下一个测试
}

TEST(FlowEngineTest, Test2) {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    // 如果需要清空缓存
    engine.getDNSEngine().clearCache();
    // 测试代码
}
```

---

## 与之前设计的对比

### 之前：每个实例独立

```cpp
// 旧设计
flow::FlowEngine engine1;
flow::FlowEngine engine2;

// engine1 和 engine2 有独立的 DNS 缓存
// 缓存不共享，可能导致重复查询
```

### 现在：单例模式

```cpp
// 新设计
flow::FlowEngine& engine1 = flow::FlowEngine::getInstance();
flow::FlowEngine& engine2 = flow::FlowEngine::getInstance();

// engine1 和 engine2 是同一个实例
// 共享 DNS 缓存，提高效率
```

---

## 性能影响

### 优势
- ✅ **更高的缓存命中率**：所有流量共享缓存
- ✅ **减少内存使用**：只有一个实例
- ✅ **减少 DNS 查询**：缓存共享减少重复查询

### 考虑
- ⚠️ **锁竞争**：多线程访问需要锁（DNSEngine 内部已处理）
- ⚠️ **缓存大小**：需要合理设置缓存大小（当前 2048 条）

---

## 最佳实践

### 1. 获取引用而不是指针

```cpp
// ✓ 推荐
flow::FlowEngine& engine = flow::FlowEngine::getInstance();

// ❌ 不推荐
flow::FlowEngine* engine = &flow::FlowEngine::getInstance();
```

### 2. 避免保存引用

```cpp
// ❌ 不推荐：保存引用
class MyClass {
private:
    flow::FlowEngine& engine_;  // 引用成员需要在构造函数初始化
public:
    MyClass() : engine_(flow::FlowEngine::getInstance()) {}
};

// ✓ 推荐：每次使用时获取
class MyClass {
public:
    void process() {
        flow::FlowEngine& engine = flow::FlowEngine::getInstance();
        // 使用 engine
    }
};
```

### 3. 清理缓存

```cpp
// 在适当的时候清理缓存
void onMemoryPressure() {
    flow::FlowEngine& engine = flow::FlowEngine::getInstance();
    engine.getDNSEngine().clearCache();
}
```

---

## 总结

### 单例模式的优势
| 特性 | 说明 |
|------|------|
| **共享缓存** | 所有流量共享 DNS 缓存 |
| **统一管理** | 集中管理所有网络流量 |
| **资源效率** | 只有一个实例，减少内存 |
| **线程安全** | C++11 保证初始化线程安全 |
| **易于使用** | 通过 getInstance() 访问 |

### 使用要点
- ✅ 使用 `getInstance()` 获取实例
- ✅ 每个线程使用独立的 `FlowContext`
- ✅ 多线程访问是安全的
- ✅ 在需要时清理缓存
- ⚠️ 注意测试时的缓存共享

FlowEngine 的单例设计使得整个应用可以高效地共享 DNS 缓存和流量信息！
